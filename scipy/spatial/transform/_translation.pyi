from __future__ import annotations
from typing import TYPE_CHECKING, Union, Tuple, Sequence
import numpy as np

if TYPE_CHECKING:
    import numpy.typing as npt

_IntegerType = int | np.integer

class Translation:
    def __init__(self, vector: npt.ArrayLike, copy: bool = True) -> None: ...
    
    @property
    def vector(self) -> np.ndarray: ...
    
    def __len__(self) -> int: ...
    
    @classmethod
    def from_vector(cls, vector: npt.ArrayLike) -> Translation: ...
    
    def as_vector(self) -> np.ndarray: ...
    
    def apply(self, points: npt.ArrayLike) -> np.ndarray: ...
    
    def __add__(self, other: Translation) -> Translation: ...
    
    def __sub__(self, other: Translation) -> Translation: ...
    
    def __mul__(self, scalar: float) -> Translation: ...
    
    def __truediv__(self, scalar: float) -> Translation: ...
    
    def inv(self) -> Translation: ...
    
    def magnitude(self) -> float: ...
    
    def approx_equal(self, other: Translation, atol: float = 1e-8) -> bool: ...
    
    @classmethod
    def concatenate(cls, translations: Sequence[Translation]) -> Translation: ...
    
    @classmethod
    def identity(cls) -> Translation: ...
    
    @classmethod
    def random(cls, random_state: Union[_IntegerType, np.random.Generator, np.random.RandomState, None] = None) -> Translation: ...
    
    def __getitem__(self, indexer: Union[int, slice]) -> float: ...